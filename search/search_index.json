{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#django-asgi-handler-with-lifespan-protocol-support","title":"Django ASGI Handler with Lifespan protocol support","text":"<ul> <li>Documentation: https://illagrenan.github.io/django-asgi-lifespan</li> <li>PyPI: https://pypi.org/project/django-asgi-lifespan/</li> <li>License: MIT</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>This package contains a subclass of the standard Django <code>ASGIHandler</code> that can   handle ASGI Lifespan Protocol. (Note: there is no change in handling HTTP requests.)</li> <li>Startup   and Shutdown Lifespan events are   converted to Django signals.</li> <li>Signal receivers can be awaited. This way it is possible for example to   create aiohttp ClientSession   /httpx client when the application starts and close these resources safely when   the application shuts down. This concept is similar to events in   FastAPI (https://fastapi.tiangolo.com/advanced/events/).</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p> This package is experimental. Lifespan signals work correctly only under uvicorn.</p> <ol> <li> <p>Install the package. Only Python 3.10 and Django 4 are supported. </p> <pre><code>$ pip install --upgrade django-asgi-lifespan\n</code></pre> </li> <li> <p>Modify <code>asgi.py</code> to use a ASGI Lifespan compatible handler.</p> asgi.py<pre><code>from django_asgi_lifespan.asgi import get_asgi_application\n\ndjango_application = get_asgi_application()\n\n\nasync def application(scope, receive, send):\n    if scope[\"type\"] in {\"http\", \"lifespan\"}:\n        await django_application(scope, receive, send)\n    else:\n        raise NotImplementedError(f\"Unknown scope type {scope['type']}\")\n</code></pre> </li> <li> <p>Subscribe your (async) code to the <code>asgi_startup</code> and <code>asgi_shutdown</code> Django signals that are sent when the server starts/shuts down. See usage for a more advanced code sample.</p> handlers.py<pre><code>import asyncio\n\nimport httpx\n\nHTTPX_CLIENT = None\n_signal_lock = asyncio.Lock()\n\n\nasync def create_httpx_client():\n    global HTTPX_CLIENT\n\n    async with _signal_lock:\n        if not HTTPX_CLIENT:\n            HTTPX_CLIENT = httpx.AsyncClient()\n\n\nasync def close_httpx_client():\n    if isinstance(HTTPX_CLIENT, httpx.AsyncClient):\n        await asyncio.wait_for(asyncio.create_task(HTTPX_CLIENT.aclose()), timeout=5.0)\n</code></pre> apps.py<pre><code>from django.apps import AppConfig\n\nfrom django_asgi_lifespan.signals import asgi_shutdown, asgi_startup\nfrom .handlers_quickstart import close_httpx_client, create_httpx_client\n\n\nclass ExampleAppConfig(AppConfig):\n    def ready(self):\n        asgi_startup.connect(create_httpx_client)\n        asgi_shutdown.connect(close_httpx_client)\n</code></pre> </li> <li> <p>Use some resource (in this case the HTTPX client) e.g. in views.</p> views.py<pre><code>from django.http import HttpResponse\n\nfrom . import handlers\n\n\nasync def my_library_view(*_) -&gt; HttpResponse:\n    external_api_response = await handlers_quickstart.HTTPX_CLIENT.get(\"https://www.example.com/\")\n\n    return HttpResponse(f\"{external_api_response.text[:42]}\", content_type=\"text/plain\")\n</code></pre> </li> <li> <p>Run uvicorn:</p> </li> </ol> <p> Lifespan protocol is not supported if you run uvicorn via gunicorn using <code>worker_class</code>: <code>gunicorn -k uvicorn.workers.UvicornWorker</code>. See    other limitations in the documentation.</p> <pre><code>``` console \nuvicorn asgi:application --lifespan=on --port=8080\n```\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#010---2022-08-03","title":"[0.1.0] - 2022-08-03","text":"<ul> <li>Initial release.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p> <ol> <li>Report bugs at https://github.com/illagrenan/django-asgi-lifespan/issues.</li> <li>Fix bugs.</li> <li>Implement Features.</li> <li>Write Documentation</li> <li>Submit Feedback in Discussion at https://github.com/illagrenan/django-asgi-lifespan/discussions.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.</li> <li>The pull request should work for Python 3.10+. Check    https://github.com/illagrenan/django-asgi-lifespan/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"credits/","title":"Credits","text":""},{"location":"credits/#original-idea","title":"Original idea","text":"<p>Thanks to my question on Stackoverflow and the excellent answer I started working on this package.</p>"},{"location":"credits/#source-code","title":"Source code","text":"<ul> <li>The idea to use Django signals in the ASGI handler comes from this closed pull request: https://github.com/django/django/pull/13636</li> <li>The implementation is also based on the code sample at https://asgi.readthedocs.io/en/latest/specs/lifespan.html</li> </ul>"},{"location":"credits/#package-and-repository-structure","title":"Package and repository structure","text":"<p>This package is based on waynerv/cookiecutter-pypackage (Cookiecutter template). The main difference from the original template is that this project does not use Pre-commit hooks. All dev tools can be run manually via Taskfiles.</p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>django-asgi-lifespan</code> for local development.</p> <ol> <li>Fork the <code>django-asgi-lifespan</code> repo on GitHub.</li> <li> <p>Clone your fork locally</p> <pre><code>$ git clone git@github.com:your_name_here/django-asgi-lifespan.git\n</code></pre> </li> <li> <p>Ensure poetry is installed.</p> </li> <li> <p>Install dependencies and start your virtualenv:</p> <pre><code>$ poetry install\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</p> <pre><code>$ poetry run task test\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol> <p>Taskfile</p> <p>We recommend installing Task (https://taskfile.dev/) for easy launching of development tasks.</p>"},{"location":"development/#formatting-and-linting","title":"Formatting and linting","text":"<pre><code>$ poetry task format\n</code></pre>"},{"location":"development/#tests","title":"Tests","text":"<pre><code>$ poetry task test\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>Supported Python and Django versions</p> <p>This package supports only Django release series 4.0+ and Python 3.10. If you need to support an older version in your project, please contact me or open a pull request.</p>"},{"location":"installation/#stable-release","title":"Stable release","text":"<p>Important warning</p> <p>This is an experimental package and a hobby project. Although I use this package in my production projects without any problems, it does not mean that everything will work with your project.</p> <p>Please read other limitations \u2013 especially those related to the deployment.</p> <p>To install Django ASGI Lifespan, run this command in your terminal:</p> <pre><code>$ pip install --upgrade django-asgi-lifespan\n</code></pre> <p>Do not add <code>django-asgi-lifespan</code> to <code>INSTALLED_APPS</code>.</p> <p>This is the preferred method to install Django ASGI Lifespan, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for Django ASGI Lifespan can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>$ git clone git://github.com/illagrenan/django-asgi-lifespan\n</code></pre> <p>Or download the tarball:</p> <pre><code>$ curl -OJL https://github.com/illagrenan/django-asgi-lifespan/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>$ pip install .\n</code></pre>"},{"location":"limitations/","title":"Limitations","text":"<p>This package has the following two known limitations:</p> <ol> <li>Django dev server (<code>runserver</code>) does not support the lifespan protocol, it is recommended to use ASGI servers like Uvicorn or Daphne for development.</li> <li>I had a trouble with the lifespan protocol when deploying the project via <code>gunicorn -k uvicorn.workers.UvicornWorker</code>. If you use plain uvicorn directly for development and deployment, everything should work fine. There are discussions on the topic Uvicorn vs Gunicorn+Uvicorn as a worker class: https://stackoverflow.com/questions/66362199/what-is-the-difference-between-uvicorn-and-gunicornuvicorn/71546833 or https://github.com/encode/uvicorn/issues/303.</li> </ol>"},{"location":"reference/","title":"Reference","text":"<p>The following is a reference of modules and their public functions and classes. </p> <p>Please note that this documentation is not versioned. The reference for the last successful build of the <code>main</code> branch is displayed.</p>"},{"location":"reference/#django_asgi_lifespan.asgi","title":"<code>asgi</code>","text":"<p>Public function for ASGI Application with custom ASGI handler.</p>"},{"location":"reference/#django_asgi_lifespan.asgi.get_asgi_application","title":"<code>get_asgi_application()</code>","text":"<p>The public interface to Django's custom ASGI support that supports the lifespan protocol.</p> <p>Returns:</p> Type Description <code>LifespanASGIHandler</code> <p>An ASGI 3 callable.</p> Source code in <code>django_asgi_lifespan/asgi.py</code> <pre><code>def get_asgi_application() -&gt; LifespanASGIHandler:\n\"\"\"\n    The public interface to Django's custom ASGI support\n    that supports the lifespan protocol.\n\n    :return: An ASGI 3 callable.\n    \"\"\"\n    django.setup(set_prefix=False)\n    return LifespanASGIHandler()\n</code></pre>"},{"location":"reference/#django_asgi_lifespan.handler","title":"<code>handler</code>","text":"<p>Subclass of Django ASGIHandler with ASGI Lifespan support.</p>"},{"location":"reference/#django_asgi_lifespan.handler.LifespanASGIHandler","title":"<code>LifespanASGIHandler</code>","text":"<p>         Bases: <code>ASGIHandler</code></p> <p>Custom ASGIHandler with LIfespan Protocol support.</p> Source code in <code>django_asgi_lifespan/handler.py</code> <pre><code>class LifespanASGIHandler(ASGIHandler):\n\"\"\"Custom ASGIHandler with LIfespan Protocol support.\"\"\"\n\n    async def __call__(\n        self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable\n    ) -&gt; None:\n\"\"\"\n        Handles lifespan request.\n\n        If scope is not lifespan, calls base class.\n        The standard Django `ASGIHandler` can only handle http scopes.\n\n        :return: Nothing.\n        \"\"\"\n        if scope[\"type\"] == \"lifespan\":\n            await self._handle_lifespan(scope, receive, send)\n        else:\n            await super().__call__(scope, receive, send)\n\n    async def _handle_lifespan(\n        self,\n        scope: LifespanScope,\n        receive: ASGIReceiveCallable,\n        send: ASGISendCallable,\n    ):\n\"\"\"Handle a lifespan request.\"\"\"\n        while True:\n            message = await receive()\n\n            match message[\"type\"]:\n                case \"lifespan.startup\":\n                    await self._handle_lifespan_event(signals.asgi_startup, scope)\n                    await send(\n                        LifespanStartupCompleteEvent(type=\"lifespan.startup.complete\")\n                    )\n                case \"lifespan.shutdown\":\n                    await self._handle_lifespan_event(signals.asgi_shutdown, scope)\n                    await send(\n                        LifespanShutdownCompleteEvent(type=\"lifespan.shutdown.complete\")\n                    )\n                    return\n                case _:\n                    raise ValueError(\n                        \"Unknown lifespan message type: %s\" % message[\"type\"]\n                    )\n\n    async def _handle_lifespan_event(\n        self, signal: Signal, scope: LifespanScope\n    ) -&gt; None:\n\"\"\"Handle a lifespan event.\"\"\"\n        logger.debug('Sending \"%s\" signal', signal)\n\n        # [(receiver, response), ...]\n        results = signal.send(self.__class__, scope=scope)\n\n        for _, response in results:\n            if not response:\n                continue\n\n            if inspect.isawaitable(response):\n                await response\n            else:\n                response()\n</code></pre>"},{"location":"reference/#django_asgi_lifespan.handler.LifespanASGIHandler.__call__","title":"<code>__call__(scope, receive, send)</code>  <code>async</code>","text":"<p>Handles lifespan request.</p> <p>If scope is not lifespan, calls base class. The standard Django <code>ASGIHandler</code> can only handle http scopes.</p> <p>Returns:</p> Type Description <code>None</code> <p>Nothing.</p> Source code in <code>django_asgi_lifespan/handler.py</code> <pre><code>async def __call__(\n    self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable\n) -&gt; None:\n\"\"\"\n    Handles lifespan request.\n\n    If scope is not lifespan, calls base class.\n    The standard Django `ASGIHandler` can only handle http scopes.\n\n    :return: Nothing.\n    \"\"\"\n    if scope[\"type\"] == \"lifespan\":\n        await self._handle_lifespan(scope, receive, send)\n    else:\n        await super().__call__(scope, receive, send)\n</code></pre>"},{"location":"reference/#django_asgi_lifespan.signals","title":"<code>signals</code>","text":"<p>ASGI lifespan Django signals for server startup and shutdown events.</p>"},{"location":"usage/","title":"Usage","text":"<p>Use case: Let's say you have a Django application named <code>library</code>. This application retrieves book information from an external API using HTTPX (https://www.python-httpx.org/). You want to use the HTTPX Client for efficient usage of network resources (e.g.: connection pooling, see: https://www.python-httpx.org/advanced/#why-use-a-client).</p>"},{"location":"usage/#types","title":"Types","text":"types.py<pre><code>from typing import Protocol\n\nimport httpx\n\n\nclass HTTPXAppConfig(Protocol):\n    httpx_client: httpx.AsyncClient\n</code></pre>"},{"location":"usage/#signal-handlers","title":"Signal handlers","text":"handlers.py<pre><code>import httpx\nfrom django.apps import AppConfig\n\nfrom django_asgi_lifespan.signals import asgi_shutdown, asgi_startup\nfrom .handlers import ASGILifespanSignalHandler\n\n\nclass ExampleAppConfig(AppConfig):\n    httpx_client: httpx.AsyncClient\n\n    def ready(self):\n        handler = ASGILifespanSignalHandler(app_config=self)\n\n        asgi_startup.connect(handler.startup, weak=False)\n        asgi_shutdown.connect(handler.shutdown, weak=False)\n</code></pre>"},{"location":"usage/#connect-asgi-lifespan-signals-to-the-handler","title":"Connect ASGI Lifespan signals to the handler","text":"apps.py<pre><code>import httpx\nfrom django.apps import AppConfig\n\nfrom django_asgi_lifespan.signals import asgi_shutdown, asgi_startup\nfrom .handlers import ASGILifespanSignalHandler\n\n\nclass ExampleAppConfig(AppConfig):\n    httpx_client: httpx.AsyncClient\n\n    def ready(self):\n        handler = ASGILifespanSignalHandler(app_config=self)\n\n        asgi_startup.connect(handler.startup, weak=False)\n        asgi_shutdown.connect(handler.shutdown, weak=False)\n</code></pre>"},{"location":"usage/#access-client","title":"Access client","text":"views.py<pre><code>from typing import cast\n\nfrom django.apps import apps\nfrom django.http import HttpResponse\n\nfrom .types import HTTPXAppConfig\n\n\nasync def my_library_view(*_) -&gt; HttpResponse:\n    library_app = cast(HTTPXAppConfig, apps.get_app_config(\"library\"))\n    httpx_client = library_app.httpx_client\n    external_api_response = await httpx_client.get(\"https://www.example.com/\")\n\n    return HttpResponse(f\"{external_api_response.text[:42]}\", content_type=\"text/plain\")\n</code></pre>"}]}