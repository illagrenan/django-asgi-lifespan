{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django ASGI Handler with Lifespan protocol support \u00b6 Documentation: https://illagrenan.github.io/django-asgi-lifespan PyPI: https://pypi.org/project/django-asgi-lifespan/ License: MIT Features \u00b6 This package contains a subclass of the standard Django ASGIHandler that can handle ASGI Lifespan Protocol . (Note: there is no change in handling HTTP requests.) Startup and Shutdown Lifespan events are converted to Django signals . Signal receivers can be awaited . This way it is possible for example to create aiohttp ClientSession / httpx client when the application starts and close these resources safely when the application shuts down. This concept is similar to events in FastAPI ( https://fastapi.tiangolo.com/advanced/events/ ). Quickstart \u00b6 This package is experimental. Lifespan signals work correctly only under uvicorn. Install the package. Only Python 3.10 and Django 4 are supported. $ pip install --upgrade django-asgi-lifespan Modify asgi.py to use a ASGI Lifespan compatible handler. asgi.py from django_asgi_lifespan.asgi import get_asgi_application django_application = get_asgi_application () async def application ( scope , receive , send ): if scope [ \"type\" ] in { \"http\" , \"lifespan\" }: await django_application ( scope , receive , send ) else : raise NotImplementedError ( f \"Unknown scope type { scope [ 'type' ] } \" ) Subscribe your (async) code to the asgi_startup and asgi_shutdown Django signals that are sent when the server starts/shuts down. See usage for a more advanced code sample. handlers.py import asyncio import httpx HTTPX_CLIENT = None _signal_lock = asyncio . Lock () async def create_httpx_client (): global HTTPX_CLIENT async with _signal_lock : if not HTTPX_CLIENT : HTTPX_CLIENT = httpx . AsyncClient () async def close_httpx_client (): if isinstance ( HTTPX_CLIENT , httpx . AsyncClient ): await asyncio . wait_for ( asyncio . create_task ( HTTPX_CLIENT . aclose ()), timeout = 5.0 ) apps.py from django.apps import AppConfig from django_asgi_lifespan.signals import asgi_shutdown , asgi_startup from .handlers_quickstart import close_httpx_client , create_httpx_client class ExampleAppConfig ( AppConfig ): def ready ( self ): asgi_startup . connect ( create_httpx_client ) asgi_shutdown . connect ( close_httpx_client ) Use some resource (in this case the HTTPX client) e.g. in views. views.py from django.http import HttpResponse from . import handlers async def my_library_view ( * _ ) -> HttpResponse : external_api_response = await handlers_quickstart . HTTPX_CLIENT . get ( \"https://www.example.com/\" ) return HttpResponse ( f \" { external_api_response . text [: 42 ] } \" , content_type = \"text/plain\" ) Run uvicorn: Lifespan protocol is not supported if you run uvicorn via gunicorn using worker_class : gunicorn -k uvicorn.workers.UvicornWorker . See other limitations in the documentation. ``` console uvicorn asgi:application --lifespan=on --port=8080 ```","title":"Home"},{"location":"#django-asgi-handler-with-lifespan-protocol-support","text":"Documentation: https://illagrenan.github.io/django-asgi-lifespan PyPI: https://pypi.org/project/django-asgi-lifespan/ License: MIT","title":"Django ASGI Handler with Lifespan protocol support"},{"location":"#features","text":"This package contains a subclass of the standard Django ASGIHandler that can handle ASGI Lifespan Protocol . (Note: there is no change in handling HTTP requests.) Startup and Shutdown Lifespan events are converted to Django signals . Signal receivers can be awaited . This way it is possible for example to create aiohttp ClientSession / httpx client when the application starts and close these resources safely when the application shuts down. This concept is similar to events in FastAPI ( https://fastapi.tiangolo.com/advanced/events/ ).","title":"Features"},{"location":"#quickstart","text":"This package is experimental. Lifespan signals work correctly only under uvicorn. Install the package. Only Python 3.10 and Django 4 are supported. $ pip install --upgrade django-asgi-lifespan Modify asgi.py to use a ASGI Lifespan compatible handler. asgi.py from django_asgi_lifespan.asgi import get_asgi_application django_application = get_asgi_application () async def application ( scope , receive , send ): if scope [ \"type\" ] in { \"http\" , \"lifespan\" }: await django_application ( scope , receive , send ) else : raise NotImplementedError ( f \"Unknown scope type { scope [ 'type' ] } \" ) Subscribe your (async) code to the asgi_startup and asgi_shutdown Django signals that are sent when the server starts/shuts down. See usage for a more advanced code sample. handlers.py import asyncio import httpx HTTPX_CLIENT = None _signal_lock = asyncio . Lock () async def create_httpx_client (): global HTTPX_CLIENT async with _signal_lock : if not HTTPX_CLIENT : HTTPX_CLIENT = httpx . AsyncClient () async def close_httpx_client (): if isinstance ( HTTPX_CLIENT , httpx . AsyncClient ): await asyncio . wait_for ( asyncio . create_task ( HTTPX_CLIENT . aclose ()), timeout = 5.0 ) apps.py from django.apps import AppConfig from django_asgi_lifespan.signals import asgi_shutdown , asgi_startup from .handlers_quickstart import close_httpx_client , create_httpx_client class ExampleAppConfig ( AppConfig ): def ready ( self ): asgi_startup . connect ( create_httpx_client ) asgi_shutdown . connect ( close_httpx_client ) Use some resource (in this case the HTTPX client) e.g. in views. views.py from django.http import HttpResponse from . import handlers async def my_library_view ( * _ ) -> HttpResponse : external_api_response = await handlers_quickstart . HTTPX_CLIENT . get ( \"https://www.example.com/\" ) return HttpResponse ( f \" { external_api_response . text [: 42 ] } \" , content_type = \"text/plain\" ) Run uvicorn: Lifespan protocol is not supported if you run uvicorn via gunicorn using worker_class : gunicorn -k uvicorn.workers.UvicornWorker . See other limitations in the documentation. ``` console uvicorn asgi:application --lifespan=on --port=8080 ```","title":"Quickstart"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [0.1.0] - 2022-08-03 \u00b6 Initial release.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#010---2022-08-03","text":"Initial release.","title":"[0.1.0] - 2022-08-03"},{"location":"contributing/","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Report bugs at https://github.com/illagrenan/django-asgi-lifespan/issues . Fix bugs. Implement Features. Write Documentation Submit Feedback in Discussion at https://github.com/illagrenan/django-asgi-lifespan/discussions . Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. The pull request should work for Python 3.10+. Check https://github.com/illagrenan/django-asgi-lifespan/actions and make sure that the tests pass for all supported Python versions.","title":"Contributing"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. The pull request should work for Python 3.10+. Check https://github.com/illagrenan/django-asgi-lifespan/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"credits/","text":"Original idea \u00b6 Thanks to my question on Stackoverflow and the excellent answer I started working on this package. Source code \u00b6 The idea to use Django signals in the ASGI handler comes from this closed pull request: https://github.com/django/django/pull/13636 The implementation is also based on the code sample at https://asgi.readthedocs.io/en/latest/specs/lifespan.html Package and repository structure \u00b6 This package is based on waynerv/cookiecutter-pypackage ( Cookiecutter template). The main difference from the original template is that this project does not use Pre-commit hooks . All dev tools can be run manually via Taskfiles .","title":"Credits"},{"location":"credits/#original-idea","text":"Thanks to my question on Stackoverflow and the excellent answer I started working on this package.","title":"Original idea"},{"location":"credits/#source-code","text":"The idea to use Django signals in the ASGI handler comes from this closed pull request: https://github.com/django/django/pull/13636 The implementation is also based on the code sample at https://asgi.readthedocs.io/en/latest/specs/lifespan.html","title":"Source code"},{"location":"credits/#package-and-repository-structure","text":"This package is based on waynerv/cookiecutter-pypackage ( Cookiecutter template). The main difference from the original template is that this project does not use Pre-commit hooks . All dev tools can be run manually via Taskfiles .","title":"Package and repository structure"},{"location":"development/","text":"Get Started! \u00b6 Ready to contribute? Here's how to set up django-asgi-lifespan for local development. Fork the django-asgi-lifespan repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/django-asgi-lifespan.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run task test Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Taskfile We recommend installing Task ( https://taskfile.dev/ ) for easy launching of development tasks. Formatting and linting \u00b6 $ poetry task format Tests \u00b6 $ poetry task test","title":"Development"},{"location":"development/#get-started","text":"Ready to contribute? Here's how to set up django-asgi-lifespan for local development. Fork the django-asgi-lifespan repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/django-asgi-lifespan.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run task test Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Taskfile We recommend installing Task ( https://taskfile.dev/ ) for easy launching of development tasks.","title":"Get Started!"},{"location":"development/#formatting-and-linting","text":"$ poetry task format","title":"Formatting and linting"},{"location":"development/#tests","text":"$ poetry task test","title":"Tests"},{"location":"installation/","text":"Installation \u00b6 Supported Python and Django versions This package supports only Django release series 4.0+ and Python 3.10. If you need to support an older version in your project, please contact me or open a pull request . Stable release \u00b6 Important warning This is an experimental package and a hobby project. Although I use this package in my production projects without any problems, it does not mean that everything will work with your project. Please read other limitations \u2013 especially those related to the deployment. To install Django ASGI Lifespan, run this command in your terminal: $ pip install --upgrade django-asgi-lifespan Do not add django-asgi-lifespan to INSTALLED_APPS . This is the preferred method to install Django ASGI Lifespan, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for Django ASGI Lifespan can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/illagrenan/django-asgi-lifespan Or download the tarball : $ curl -OJL https://github.com/illagrenan/django-asgi-lifespan/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"Installation"},{"location":"installation/#installation","text":"Supported Python and Django versions This package supports only Django release series 4.0+ and Python 3.10. If you need to support an older version in your project, please contact me or open a pull request .","title":"Installation"},{"location":"installation/#stable-release","text":"Important warning This is an experimental package and a hobby project. Although I use this package in my production projects without any problems, it does not mean that everything will work with your project. Please read other limitations \u2013 especially those related to the deployment. To install Django ASGI Lifespan, run this command in your terminal: $ pip install --upgrade django-asgi-lifespan Do not add django-asgi-lifespan to INSTALLED_APPS . This is the preferred method to install Django ASGI Lifespan, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for Django ASGI Lifespan can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/illagrenan/django-asgi-lifespan Or download the tarball : $ curl -OJL https://github.com/illagrenan/django-asgi-lifespan/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"From source"},{"location":"limitations/","text":"This package has the following two known limitations: Django dev server ( runserver ) does not support the lifespan protocol, it is recommended to use ASGI servers like Uvicorn or Daphne for development. I had a trouble with the lifespan protocol when deploying the project via gunicorn -k uvicorn.workers.UvicornWorker . If you use plain uvicorn directly for development and deployment, everything should work fine. There are discussions on the topic Uvicorn vs Gunicorn+Uvicorn as a worker class: https://stackoverflow.com/questions/66362199/what-is-the-difference-between-uvicorn-and-gunicornuvicorn/71546833 or https://github.com/encode/uvicorn/issues/303 .","title":"Limitations"},{"location":"reference/","text":"The following is a reference of modules and their public functions and classes. Please note that this documentation is not versioned . The reference for the last successful build of the main branch is displayed. asgi \u00b6 Public function for ASGI Application with custom ASGI handler. get_asgi_application () \u00b6 The public interface to Django's custom ASGI support that supports the lifespan protocol. Returns: Type Description LifespanASGIHandler An ASGI 3 callable. Source code in django_asgi_lifespan/asgi.py 19 20 21 22 23 24 25 26 27 def get_asgi_application () -> LifespanASGIHandler : \"\"\" The public interface to Django's custom ASGI support that supports the lifespan protocol. :return: An ASGI 3 callable. \"\"\" django . setup ( set_prefix = False ) return LifespanASGIHandler () handler \u00b6 Subclass of Django ASGIHandler with ASGI Lifespan support. LifespanASGIHandler \u00b6 Bases: ASGIHandler Custom ASGIHandler with LIfespan Protocol support. Source code in django_asgi_lifespan/handler.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class LifespanASGIHandler ( ASGIHandler ): \"\"\"Custom ASGIHandler with LIfespan Protocol support.\"\"\" async def __call__ ( self , scope : Scope , receive : ASGIReceiveCallable , send : ASGISendCallable ) -> None : \"\"\" Handles lifespan request. If scope is not lifespan, calls base class. The standard Django `ASGIHandler` can only handle http scopes. :return: Nothing. \"\"\" if scope [ \"type\" ] == \"lifespan\" : await self . _handle_lifespan ( scope , receive , send ) else : await super () . __call__ ( scope , receive , send ) async def _handle_lifespan ( self , scope : LifespanScope , receive : ASGIReceiveCallable , send : ASGISendCallable , ): \"\"\"Handle a lifespan request.\"\"\" while True : message = await receive () match message [ \"type\" ]: case \"lifespan.startup\" : await self . _handle_lifespan_event ( signals . asgi_startup , scope ) await send ( LifespanStartupCompleteEvent ( type = \"lifespan.startup.complete\" ) ) case \"lifespan.shutdown\" : await self . _handle_lifespan_event ( signals . asgi_shutdown , scope ) await send ( LifespanShutdownCompleteEvent ( type = \"lifespan.shutdown.complete\" ) ) return case _ : raise ValueError ( \"Unknown lifespan message type: %s \" % message [ \"type\" ] ) async def _handle_lifespan_event ( self , signal : Signal , scope : LifespanScope ) -> None : \"\"\"Handle a lifespan event.\"\"\" logger . debug ( 'Sending \" %s \" signal' , signal ) # [(receiver, response), ...] results = signal . send ( self . __class__ , scope = scope ) for _ , response in results : if not response : continue if inspect . isawaitable ( response ): await response else : response () __call__ ( scope , receive , send ) async \u00b6 Handles lifespan request. If scope is not lifespan, calls base class. The standard Django ASGIHandler can only handle http scopes. Returns: Type Description None Nothing. Source code in django_asgi_lifespan/handler.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 async def __call__ ( self , scope : Scope , receive : ASGIReceiveCallable , send : ASGISendCallable ) -> None : \"\"\" Handles lifespan request. If scope is not lifespan, calls base class. The standard Django `ASGIHandler` can only handle http scopes. :return: Nothing. \"\"\" if scope [ \"type\" ] == \"lifespan\" : await self . _handle_lifespan ( scope , receive , send ) else : await super () . __call__ ( scope , receive , send ) signals \u00b6 ASGI lifespan Django signals for server startup and shutdown events.","title":"Reference"},{"location":"reference/#django_asgi_lifespan.asgi","text":"Public function for ASGI Application with custom ASGI handler.","title":"asgi"},{"location":"reference/#django_asgi_lifespan.asgi.get_asgi_application","text":"The public interface to Django's custom ASGI support that supports the lifespan protocol. Returns: Type Description LifespanASGIHandler An ASGI 3 callable. Source code in django_asgi_lifespan/asgi.py 19 20 21 22 23 24 25 26 27 def get_asgi_application () -> LifespanASGIHandler : \"\"\" The public interface to Django's custom ASGI support that supports the lifespan protocol. :return: An ASGI 3 callable. \"\"\" django . setup ( set_prefix = False ) return LifespanASGIHandler ()","title":"get_asgi_application()"},{"location":"reference/#django_asgi_lifespan.handler","text":"Subclass of Django ASGIHandler with ASGI Lifespan support.","title":"handler"},{"location":"reference/#django_asgi_lifespan.handler.LifespanASGIHandler","text":"Bases: ASGIHandler Custom ASGIHandler with LIfespan Protocol support. Source code in django_asgi_lifespan/handler.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class LifespanASGIHandler ( ASGIHandler ): \"\"\"Custom ASGIHandler with LIfespan Protocol support.\"\"\" async def __call__ ( self , scope : Scope , receive : ASGIReceiveCallable , send : ASGISendCallable ) -> None : \"\"\" Handles lifespan request. If scope is not lifespan, calls base class. The standard Django `ASGIHandler` can only handle http scopes. :return: Nothing. \"\"\" if scope [ \"type\" ] == \"lifespan\" : await self . _handle_lifespan ( scope , receive , send ) else : await super () . __call__ ( scope , receive , send ) async def _handle_lifespan ( self , scope : LifespanScope , receive : ASGIReceiveCallable , send : ASGISendCallable , ): \"\"\"Handle a lifespan request.\"\"\" while True : message = await receive () match message [ \"type\" ]: case \"lifespan.startup\" : await self . _handle_lifespan_event ( signals . asgi_startup , scope ) await send ( LifespanStartupCompleteEvent ( type = \"lifespan.startup.complete\" ) ) case \"lifespan.shutdown\" : await self . _handle_lifespan_event ( signals . asgi_shutdown , scope ) await send ( LifespanShutdownCompleteEvent ( type = \"lifespan.shutdown.complete\" ) ) return case _ : raise ValueError ( \"Unknown lifespan message type: %s \" % message [ \"type\" ] ) async def _handle_lifespan_event ( self , signal : Signal , scope : LifespanScope ) -> None : \"\"\"Handle a lifespan event.\"\"\" logger . debug ( 'Sending \" %s \" signal' , signal ) # [(receiver, response), ...] results = signal . send ( self . __class__ , scope = scope ) for _ , response in results : if not response : continue if inspect . isawaitable ( response ): await response else : response ()","title":"LifespanASGIHandler"},{"location":"reference/#django_asgi_lifespan.handler.LifespanASGIHandler.__call__","text":"Handles lifespan request. If scope is not lifespan, calls base class. The standard Django ASGIHandler can only handle http scopes. Returns: Type Description None Nothing. Source code in django_asgi_lifespan/handler.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 async def __call__ ( self , scope : Scope , receive : ASGIReceiveCallable , send : ASGISendCallable ) -> None : \"\"\" Handles lifespan request. If scope is not lifespan, calls base class. The standard Django `ASGIHandler` can only handle http scopes. :return: Nothing. \"\"\" if scope [ \"type\" ] == \"lifespan\" : await self . _handle_lifespan ( scope , receive , send ) else : await super () . __call__ ( scope , receive , send )","title":"__call__()"},{"location":"reference/#django_asgi_lifespan.signals","text":"ASGI lifespan Django signals for server startup and shutdown events.","title":"signals"},{"location":"usage/","text":"Use case: Let's say you have a Django application named library . This application retrieves book information from an external API using HTTPX ( https://www.python-httpx.org/ ). You want to use the HTTPX Client for efficient usage of network resources (e.g.: connection pooling, see: https://www.python-httpx.org/advanced/#why-use-a-client ). Types \u00b6 types.py from typing import Protocol import httpx class HTTPXAppConfig ( Protocol ): httpx_client : httpx . AsyncClient Signal handlers \u00b6 handlers.py import httpx from django.apps import AppConfig from django_asgi_lifespan.signals import asgi_shutdown , asgi_startup from .handlers import ASGILifespanSignalHandler class ExampleAppConfig ( AppConfig ): httpx_client : httpx . AsyncClient def ready ( self ): handler = ASGILifespanSignalHandler ( app_config = self ) asgi_startup . connect ( handler . startup , weak = False ) asgi_shutdown . connect ( handler . shutdown , weak = False ) Connect ASGI Lifespan signals to the handler \u00b6 apps.py import httpx from django.apps import AppConfig from django_asgi_lifespan.signals import asgi_shutdown , asgi_startup from .handlers import ASGILifespanSignalHandler class ExampleAppConfig ( AppConfig ): httpx_client : httpx . AsyncClient def ready ( self ): handler = ASGILifespanSignalHandler ( app_config = self ) asgi_startup . connect ( handler . startup , weak = False ) asgi_shutdown . connect ( handler . shutdown , weak = False ) Access client \u00b6 views.py from typing import cast from django.apps import apps from django.http import HttpResponse from .types import HTTPXAppConfig async def my_library_view ( * _ ) -> HttpResponse : library_app = cast ( HTTPXAppConfig , apps . get_app_config ( \"library\" )) httpx_client = library_app . httpx_client external_api_response = await httpx_client . get ( \"https://www.example.com/\" ) return HttpResponse ( f \" { external_api_response . text [: 42 ] } \" , content_type = \"text/plain\" )","title":"Usage"},{"location":"usage/#types","text":"types.py from typing import Protocol import httpx class HTTPXAppConfig ( Protocol ): httpx_client : httpx . AsyncClient","title":"Types"},{"location":"usage/#signal-handlers","text":"handlers.py import httpx from django.apps import AppConfig from django_asgi_lifespan.signals import asgi_shutdown , asgi_startup from .handlers import ASGILifespanSignalHandler class ExampleAppConfig ( AppConfig ): httpx_client : httpx . AsyncClient def ready ( self ): handler = ASGILifespanSignalHandler ( app_config = self ) asgi_startup . connect ( handler . startup , weak = False ) asgi_shutdown . connect ( handler . shutdown , weak = False )","title":"Signal handlers"},{"location":"usage/#connect-asgi-lifespan-signals-to-the-handler","text":"apps.py import httpx from django.apps import AppConfig from django_asgi_lifespan.signals import asgi_shutdown , asgi_startup from .handlers import ASGILifespanSignalHandler class ExampleAppConfig ( AppConfig ): httpx_client : httpx . AsyncClient def ready ( self ): handler = ASGILifespanSignalHandler ( app_config = self ) asgi_startup . connect ( handler . startup , weak = False ) asgi_shutdown . connect ( handler . shutdown , weak = False )","title":"Connect ASGI Lifespan signals to the handler"},{"location":"usage/#access-client","text":"views.py from typing import cast from django.apps import apps from django.http import HttpResponse from .types import HTTPXAppConfig async def my_library_view ( * _ ) -> HttpResponse : library_app = cast ( HTTPXAppConfig , apps . get_app_config ( \"library\" )) httpx_client = library_app . httpx_client external_api_response = await httpx_client . get ( \"https://www.example.com/\" ) return HttpResponse ( f \" { external_api_response . text [: 42 ] } \" , content_type = \"text/plain\" )","title":"Access client"}]}