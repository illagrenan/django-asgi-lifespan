{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Django ASGI Handler with Lifespan protocol support <ul> <li>Documentation: https://illagrenan.github.io/django-asgi-lifespan</li> <li>PyPI: https://pypi.org/project/django-asgi-lifespan/</li> <li>License: MIT</li> </ul>"},{"location":"#main-features","title":"Main features","text":"<pre><code>async def example_view(request) -&gt; HttpResponse:\n    # The client is intanciated just once when the application starts,\n    # and closed when the server shuts down\n    httpx_client: httpx.AsyncClient = request.state[\"httpx_client\"]\n</code></pre> <ul> <li>The package includes a Django <code>ASGIHandler</code> subclass that handles the ASGI Lifespan Protocol without affecting HTTP request handling.</li> <li>Startup   and Shutdown Lifespan events are   converted to Django signals.</li> <li>The package allows for awaiting on signal receivers. This means you can set up things like an aiohttp <code>ClientSession</code> or an HTTPX <code>AsyncClient</code> when your app starts, and close them properly when your app ends. This concept is similar to events in FastAPI.</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<ol> <li> <p>Python <code>^3.10 || ^3.11 || ^3.12</code> and Django <code>^4.2 || ^5.0.3</code> are supported. To install this package run:     <pre><code>$ poetry add django-asgi-lifespan@latest\n</code></pre></p> <p>or</p> <pre><code>$ pip install --upgrade django-asgi-lifespan\n</code></pre> </li> <li> <p>Modify <code>asgi.py</code> to use a ASGI Lifespan compatible handler.</p> asgi.py<pre><code>from django_asgi_lifespan.asgi import get_asgi_application\n\ndjango_application = get_asgi_application()\n\n\nasync def application(scope, receive, send):\n    if scope[\"type\"] in {\"http\", \"lifespan\"}:\n        await django_application(scope, receive, send)\n    else:\n        raise NotImplementedError(\n            f\"Unknown scope type {scope['type']}\"\n        )\n</code></pre> </li> <li> <p>Add state middleware:</p> <p><pre><code>MIDDLEWARE = [\n    # ...\n    'django_asgi_lifespan.middleware.AsyncMiddleware',\n    # ...\n]\n</code></pre> 4. Register async context manager:</p> context.py<pre><code>from contextlib import asynccontextmanager\n\nimport httpx\n\nfrom django_asgi_lifespan.types import State\n\n\n@asynccontextmanager\nasync def httpx_lifespan_manager() -&gt; State:\n    state = {\n        \"httpx_client\": httpx.AsyncClient()\n    }\n\n    try:\n        yield state\n    finally:\n        await state[\"httpx_client\"].aclose()\n</code></pre> apps.py<pre><code>from django.apps import AppConfig\n\nfrom django_asgi_lifespan.register import register_lifespan_manager\nfrom .context import (\n    httpx_lifespan_manager,\n)\n\n\nclass ExampleAppConfig(AppConfig):\n\n    def ready(self):\n        register_lifespan_manager(\n            context_manager=httpx_lifespan_manager\n        )\n</code></pre> </li> <li> <p>Use some resource (in this case the HTTPX client) in views.</p> views.py<pre><code>from http import HTTPStatus\n\nimport httpx\nfrom django.http import HttpResponse\n\n\nasync def example_view(request) -&gt; HttpResponse:\n    httpx_client: httpx.AsyncClient = request.state[\"httpx_client\"]\n\n    await httpx_client.head(\"https://www.example.com/\")\n\n    return HttpResponse(\n        \"OK\",\n        status=HTTPStatus.OK,\n        content_type=\"text/plain; charset=utf-8\",\n    )\n</code></pre> </li> <li> <p>Run uvicorn:</p> <pre><code>uvicorn asgi:application --lifespan=on --port=8080\n</code></pre> </li> </ol>"},{"location":"asgi/","title":"ASGI servers compatibility","text":"<p>To provide asynchronous support for the project, an ASGI server is necessary. The table below presents a summary of popular ASGI servers and their compatibility with this project.</p> <p>ASGI compatibility</p> <p>If there is an incompatibility listed in this table, your project will work with the server as you are used to. This plugin only handles lifespan events \u2014 if they are not provided by the ASGI server, the signals will not be handled.</p> <p>The same should be valid for other ASGI servers not listed here. If you run into any problems, please file a Github issue.</p> ASGI server Lifespan support Lifespan scope state support Uvicorn  Yes  Yes gunicorn with UvicornWorker<sup>1</sup>  Yes  Yes Granian  Yes  Yes Hypercorn  Yes  Not compatible Daphne  Not compatible not relevant Django runserver  Not compatible not relevant NGINX Unit  Not yet tested  Not yet tested"},{"location":"asgi/#uvicorn","title":"Uvicorn","text":"<p>Uvicorn is the most tested ASGI server by the author of this plugin. The author uses uvicorn for development, testing and production. In production it is perfectly fine to use uvicorn without gunicorn, see:</p> <ul> <li>https://stackoverflow.com/questions/66362199/what-is-the-difference-between-uvicorn-and-gunicornuvicorn/71546833</li> <li>https://github.com/encode/uvicorn/issues/303</li> </ul>"},{"location":"asgi/#hypercorn","title":"Hypercorn","text":"<p>Hypercorn supports lifespan protocol. It does not support lifespan scope state, see these PRs:</p> <ul> <li>https://github.com/pgjones/hypercorn/pull/107</li> <li>https://github.com/pgjones/hypercorn/pull/110</li> </ul>"},{"location":"asgi/#daphne","title":"Daphne","text":"<p>Daphne does not support the lifespan protocol at all. See this issue: https://github.com/django/daphne/issues/264.</p> <p>You can use Daphne, but asynchronous start/shutdown signals will not be handled.</p> <ol> <li> <p>Please note that gunicorn does not support Windows (https://github.com/benoitc/gunicorn/issues/524).\u00a0\u21a9</p> </li> </ol>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#030-2024-03-05","title":"[0.3.0] - 2024-03-05","text":"<p> Github release</p>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Lifespan async context managers are now supported (inspired by Lifespan events in FastAPI). Global variables are no longer necessary for the state management; objects required throughout the application lifecycle are now held in the lifespan scope state. Further details can be found in the ASGI spec. Previous signals (startup and shutdown) remain supported with no plans for their removal. The new, preferred method to manage state is via an async context manager.</li> <li>All major ASGI servers have been tested, an overview of their support is in separate page. It\u00a0is worth mentioning that the gunicorn+uvicorn combo is now working without problems.</li> <li>Development: Add support for pre-commit.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>More tests.</li> <li>Better documentation.</li> </ul>"},{"location":"changelog/#breaking-changes","title":"Breaking changes","text":"<ul> <li>Drop support for Django <code>&gt;=4.0.0, &lt;4.2.0</code> and <code>&gt;=5.0.0, &lt;5.0.3</code>. Supported versions include <code>^4.2 || ^5.0.3</code> (<code>^4.2</code> is LTS).</li> <li>If lifespan signals fail, two new events are sent to the ASGI server: <code>lifespan.startup.failed</code> and <code>lifespan.shutdown.failed</code>. This could stop servers, like uvicorn, from starting if a <code>lifespan.startup.failed</code> event happens. This update makes it easier to find and fix errors, as they are not hidden anymore.</li> </ul>"},{"location":"changelog/#020-2024-02-09","title":"[0.2.0] - 2024-02-09","text":"<p> Github release</p>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support for Django 5.     Support for Django 5 has proven problematic due to this bug: https://code.djangoproject.com/ticket/35174. As soon as a new version of Django is released with a fix, a new version of this plugin will be released. At the moment, this plugin includes the Signal handler from here: https://github.com/django/django/pull/17837.</li> <li>Support for Python 3.12.</li> </ul>"},{"location":"changelog/#010-2022-08-03","title":"[0.1.0] - 2022-08-03","text":"<p> Github release</p> <ul> <li>Initial release.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p> <ol> <li>Report bugs at https://github.com/illagrenan/django-asgi-lifespan/issues.</li> <li>Fix bugs.</li> <li>Implement Features.</li> <li>Write Documentation</li> <li>Submit Feedback in Discussion at https://github.com/illagrenan/django-asgi-lifespan/discussions.</li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.</li> <li>The pull request should work for Python 3.10+. Check    https://github.com/illagrenan/django-asgi-lifespan/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"credits/","title":"Credits","text":""},{"location":"credits/#original-idea","title":"Original idea","text":"<p>Thanks to this great answer on StackOverflow, this package was created.</p>"},{"location":"credits/#source-code","title":"Source code","text":"<ul> <li>The idea to use Django signals in the ASGI handler comes from this closed pull request: https://github.com/django/django/pull/13636</li> <li>The implementation of lifespan handling is based on the code sample from ASGI specification.</li> <li>The design and usage is inspired by Starlette and FastAPI.</li> </ul>"},{"location":"credits/#package-and-repository-structure","title":"Package and repository structure","text":"<p>This package is based on waynerv/cookiecutter-pypackage (Cookiecutter template). The main difference from the original template is that this project does not use Pre-commit hooks. All dev tools can be run manually via Taskfiles.</p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>django-asgi-lifespan</code> for local development.</p> <ol> <li>Fork the <code>django-asgi-lifespan</code> repo on GitHub.</li> <li> <p>Clone your fork locally</p> <pre><code>$ git clone git@github.com:your_name_here/django-asgi-lifespan.git\n</code></pre> </li> <li> <p>Ensure Poetry is installed.</p> </li> <li> <p>Install dependencies and start your virtualenv:</p> <pre><code>$ poetry install\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> </li> </ol> <p>Now you can make your changes locally.</p> <ol> <li> <p>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</p> <pre><code>$ task test\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol> <p>Taskfile</p> <p>We recommend installing Task (https://taskfile.dev/) for easy launching of development tasks.</p>"},{"location":"development/#formatting-and-linting","title":"Formatting and linting","text":"<pre><code>$ poetry task format\n</code></pre>"},{"location":"development/#tests","title":"Tests","text":"<pre><code>$ poetry task test\n</code></pre>"},{"location":"development/#run-a-django-test-project-locally","title":"Run a Django test project locally","text":"<p>The tests include a Django test project for integration testing. You can also run this test project locally (like any other Django project), sometimes it's useful to observe how a real application behaves.</p> <pre><code>$ cd ./tests/\n$ poetry run uvicorn django_test_application.asgi:application --log-level=debug --reload\n$ curl -v http://127.0.0.1:8000/test\n</code></pre>"},{"location":"development/#test-asgi-servers","title":"Test ASGI servers","text":"<pre><code>$ cd ./tests/\n$ poetry run uvicorn django_test_application.asgi:application --log-level=debug --reload\n$ poetry run hypercorn django_test_application.asgi:application --log-level debug --reload\n$ poetry run daphne django_test_application.asgi:application\n$ poetry run granian --interface asgi django_test_application.asgi:application\n$ poetry run gunicorn django_test_application.asgi:application -k uvicorn.workers.UvicornWorker --log-level debug --reload\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#using-package-manager","title":"Using package manager","text":"<p>To install Django ASGI Lifespan, run following command in your terminal:</p>  Poetry pip <pre><code>$ poetry add django-asgi-lifespan@latest\n</code></pre> <pre><code>$ pip install --upgrade django-asgi-lifespan\n</code></pre> <p>Do not add <code>django-asgi-lifespan</code> to <code>INSTALLED_APPS</code>.</p> <p>This is the preferred method to install this package, as it will always install the most recent stable release.</p>"},{"location":"installation/#from-source","title":"From source","text":"<p>The source for Django ASGI Lifespan can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>$ git clone git://github.com/illagrenan/django-asgi-lifespan\n</code></pre> <p>Or download the tarball:</p> <pre><code>$ curl --proto '=https' --tlsv1.3 -fsSL -OJ https://github.com/illagrenan/django-asgi-lifespan/tarball/main\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>$ pip install .\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>The following is a reference of modules and their public functions and classes. </p> <p>Please note that this documentation is not versioned. The reference for the last successful build of the <code>main</code> branch is displayed.</p>"},{"location":"reference/#django_asgi_lifespan.asgi","title":"<code>asgi</code>","text":"<p>Public function for ASGI Application with custom ASGI handler.</p>"},{"location":"reference/#django_asgi_lifespan.asgi.get_asgi_application","title":"<code>get_asgi_application()</code>","text":"<p>The public interface to Django's custom ASGI support that supports the lifespan protocol.</p> This is modified copy of <p>https://github.com/django/django/blob/main/django/core/asgi.py</p> <p>:return: An ASGI 3 callable.</p> Source code in <code>django_asgi_lifespan/asgi.py</code> <pre><code>def get_asgi_application() -&gt; LifespanASGIHandler:\n    \"\"\"\n    The public interface to Django's custom ASGI support\n    that supports the lifespan protocol.\n\n    This is modified copy of:\n        &lt;https://github.com/django/django/blob/main/django/core/asgi.py&gt;\n\n    :return: An ASGI 3 callable.\n    \"\"\"\n    django.setup(set_prefix=False)\n    return LifespanASGIHandler()\n</code></pre>"},{"location":"reference/#django_asgi_lifespan.dispatcher","title":"<code>dispatcher</code>","text":""},{"location":"reference/#django_asgi_lifespan.errors","title":"<code>errors</code>","text":""},{"location":"reference/#django_asgi_lifespan.events","title":"<code>events</code>","text":""},{"location":"reference/#django_asgi_lifespan.events.send_lifespan_signal_collecting_contexts","title":"<code>send_lifespan_signal_collecting_contexts(signal, scope)</code>  <code>async</code>","text":"<p>Dispatches the given signal. Returns a list of async context managers.</p> Source code in <code>django_asgi_lifespan/events.py</code> <pre><code>async def send_lifespan_signal_collecting_contexts(\n    signal: CompatAsyncSignal, scope: LifespanScope\n) -&gt; List[Callable[[], LifespanManager]]:\n    \"\"\"\n    Dispatches the given signal. Returns a list of async context managers.\n    \"\"\"\n    logger.debug(\"Dispatching signal: %s\", signal)\n\n    if \"state\" not in scope:\n        logger.warning(\"Missing state in scope. Cannot dispatch signal.\")\n        raise MissingScopeStateError(\"Missing state in scope. Cannot dispatch signal.\")\n\n    logger.debug(\n        \"Awaiting signal `%s` using compat `compat_asend_async_only` method.\", signal\n    )\n\n    # List of tuple pairs [(receiver, response), ...].\n    receiver_responses: List[Tuple[Any, Callable[[], LifespanManager]]] = (\n        await signal.compat_asend_async_only(\n            LifespanSender, scope=scope, state=scope[\"state\"]\n        )\n    )\n    context_managers = [context_manager for _, context_manager in receiver_responses]\n\n    return context_managers\n</code></pre>"},{"location":"reference/#django_asgi_lifespan.events.send_lifespan_signal_compat","title":"<code>send_lifespan_signal_compat(*, signal, scope)</code>  <code>async</code>","text":"<p>Dispatches the given signal.</p> Source code in <code>django_asgi_lifespan/events.py</code> <pre><code>async def send_lifespan_signal_compat(*, signal: Signal, scope: LifespanScope) -&gt; None:\n    \"\"\"\n    Dispatches the given signal.\n    \"\"\"\n    logger.debug(\"Dispatching signal: %s\", signal)\n\n    if callable(getattr(signal, \"asend\", None)):\n        logger.debug(\"Awaiting signal using native `asend` method: %s\", signal)\n        await signal.asend(sender=LifespanSender, scope=scope)\n    else:\n        logger.debug(\"Sending signal using synchronous `send` method: %s\", signal)\n        responses = signal.send(sender=LifespanSender, scope=scope)\n\n        # Synchronous send method returns coroutine objects, that need to be awaited\n        for _, response in responses:\n            if not response:\n                continue\n\n            if inspect.isawaitable(response):\n                await response\n            else:\n                response()\n\n    logger.debug(\"Signal: %s dispatched\", signal)\n</code></pre>"},{"location":"reference/#django_asgi_lifespan.handler","title":"<code>handler</code>","text":"<p>Subclass of Django ASGIHandler with ASGI Lifespan support.</p>"},{"location":"reference/#django_asgi_lifespan.handler.LifespanASGIHandler","title":"<code>LifespanASGIHandler</code>","text":"<p>             Bases: <code>ASGIHandler</code></p> <p>A subclass of ASGIHandler that supports the ASGI Lifespan protocol.</p> Source code in <code>django_asgi_lifespan/handler.py</code> <pre><code>class LifespanASGIHandler(ASGIHandler):\n    \"\"\"A subclass of ASGIHandler that supports the ASGI Lifespan protocol.\"\"\"\n\n    _lifespan_event_dispatcher: LifespanEventDispatcher\n\n    def __init__(self):\n        super().__init__()\n        self._lifespan_event_dispatcher = LifespanEventDispatcher()\n\n    async def __call__(\n        self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable\n    ) -&gt; None:\n        \"\"\"\n        If scope type is lifespan, handle lifespan request.\n        Otherwise, delegate to the superclass call method.\n\n        The base Django `ASGIHandler` can only handle http scope.\n        \"\"\"\n\n        if scope[\"type\"] == \"lifespan\":\n            await self._handle_lifespan(scope, receive, send)\n        else:\n            await super().__call__(scope, receive, send)\n\n    async def _handle_lifespan(\n        self,\n        scope: LifespanScope,\n        receive: ASGIReceiveCallable,\n        send: ASGISendCallable,\n    ) -&gt; None:\n        \"\"\"Process lifespan request events.\"\"\"\n\n        while True:\n            message: ASGIReceiveEvent = await receive()\n\n            match message[\"type\"]:\n                case \"lifespan.startup\":\n\n                    try:\n                        await self._lifespan_event_dispatcher.startup(scope)\n                    except Exception as exc:\n                        await send(\n                            LifespanStartupFailedEvent(\n                                type=\"lifespan.startup.failed\", message=str(exc)\n                            )\n                        )\n                        raise\n                    else:\n                        await send(\n                            LifespanStartupCompleteEvent(\n                                type=\"lifespan.startup.complete\"\n                            )\n                        )\n\n                case \"lifespan.shutdown\":\n                    try:\n                        await self._lifespan_event_dispatcher.shutdown(scope)\n                    except Exception as exc:\n                        await send(\n                            LifespanShutdownFailedEvent(\n                                type=\"lifespan.shutdown.failed\", message=str(exc)\n                            )\n                        )\n                        raise\n                    else:\n                        await send(\n                            LifespanShutdownCompleteEvent(\n                                type=\"lifespan.shutdown.complete\"\n                            )\n                        )\n                        # The return statement is important here to break the while loop\n                        # and prevent the function from processing any further messages\n                        # after the shutdown event.\n                        # Ref.:\n                        # https://asgi.readthedocs.io/en/latest/specs/lifespan.html\n                        return\n\n                case _:\n                    raise ValueError(\n                        f\"Unknown lifespan message type: {message['type']}\"\n                    )\n</code></pre>"},{"location":"reference/#django_asgi_lifespan.handler.LifespanASGIHandler.__call__","title":"<code>__call__(scope, receive, send)</code>  <code>async</code>","text":"<p>If scope type is lifespan, handle lifespan request. Otherwise, delegate to the superclass call method.</p> <p>The base Django <code>ASGIHandler</code> can only handle http scope.</p> Source code in <code>django_asgi_lifespan/handler.py</code> <pre><code>async def __call__(\n    self, scope: Scope, receive: ASGIReceiveCallable, send: ASGISendCallable\n) -&gt; None:\n    \"\"\"\n    If scope type is lifespan, handle lifespan request.\n    Otherwise, delegate to the superclass call method.\n\n    The base Django `ASGIHandler` can only handle http scope.\n    \"\"\"\n\n    if scope[\"type\"] == \"lifespan\":\n        await self._handle_lifespan(scope, receive, send)\n    else:\n        await super().__call__(scope, receive, send)\n</code></pre>"},{"location":"reference/#django_asgi_lifespan.middleware","title":"<code>middleware</code>","text":""},{"location":"reference/#django_asgi_lifespan.register","title":"<code>register</code>","text":""},{"location":"reference/#django_asgi_lifespan.register.register_lifespan_manager","title":"<code>register_lifespan_manager(*, context_manager)</code>","text":"<p>Registers a context manager for lifecycle events</p> Source code in <code>django_asgi_lifespan/register.py</code> <pre><code>def register_lifespan_manager(*, context_manager: LifespanManager) -&gt; None:\n    \"\"\"\n    Registers a context manager for lifecycle events\n    \"\"\"\n    wrapper = LifespanContextManagerSignalWrapper(context_manager)\n    # weak=False is important here, otherwise the receiver will be garbage collected\n    asgi_lifespan.connect(wrapper.receiver, sender=None, weak=False, dispatch_uid=None)\n</code></pre>"},{"location":"reference/#django_asgi_lifespan.signals","title":"<code>signals</code>","text":"<p>ASGI lifespan Django signals for server startup and shutdown events.</p>"},{"location":"reference/#django_asgi_lifespan.types","title":"<code>types</code>","text":""},{"location":"how_to_use/context_manager/","title":"State manager (preferred)","text":""},{"location":"how_to_use/context_manager/#how-does-it-work","title":"How does it work","text":"Simplified sequence diagram. See the full version of the diagram. <p>When you execute the Django project using the ASGI server (like uvicorn), it sends lifespan events at its startup. These lifespan events are ignored by the standard Django ASGI handler. The lifespan events include the lifespan scope state, which is a Python dictionary that is preserved by the ASGI server and allowed to be modified by the developer. Hence, it's a suitable location for storing global application states or shared objects. For instance, one could create a shared HTTPX async client to implement connection pooling.</p>"},{"location":"how_to_use/context_manager/#accessing-the-shared-state","title":"Accessing the shared state","text":"<p>To access the shared state within a view, your project must include middleware. This middleware assigns a new attribute to the request object, using the state it receives from the ASGI server.</p> <pre><code>MIDDLEWARE = [\n    # ...\n    'django_asgi_lifespan.middleware.AsyncMiddleware',\n    # ...\n]\n</code></pre>"},{"location":"how_to_use/context_manager/#context-manager","title":"Context manager","text":"<p>You must define an async context manager. The code for this can be placed anywhere; in this example, the function is defined in the <code>context.py</code> file. The code up to the yield statement is executed when the ASGI server starts, and the remaining part is executed when the server shuts down.</p> context.py<pre><code>from contextlib import asynccontextmanager\n\nimport httpx\n\nfrom django_asgi_lifespan.types import State\n\n\n@asynccontextmanager\nasync def httpx_lifespan_manager() -&gt; State:\n    state = {\n        \"httpx_client\": httpx.AsyncClient()\n    }\n\n    try:\n        yield state\n    finally:\n        await state[\"httpx_client\"].aclose()\n</code></pre>"},{"location":"how_to_use/context_manager/#registering-the-context-manager","title":"Registering the context manager","text":"<p>The manager that you have just defined needs to be registered. The most suitable location for registration is Django AppConfig.</p> apps.py<pre><code>from django.apps import AppConfig\n\nfrom django_asgi_lifespan.register import register_lifespan_manager\nfrom .context import (\n    httpx_lifespan_manager,\n)\n\n\nclass ExampleAppConfig(AppConfig):\n\n    def ready(self):\n        register_lifespan_manager(\n            context_manager=httpx_lifespan_manager\n        )\n</code></pre>"},{"location":"how_to_use/context_manager/#view","title":"View","text":"<p>After the above steps, you can access the shared state in the views.</p> views.py<pre><code>from http import HTTPStatus\n\nimport httpx\nfrom django.http import HttpResponse\n\n\nasync def example_view(request) -&gt; HttpResponse:\n    httpx_client: httpx.AsyncClient = request.state[\"httpx_client\"]\n\n    await httpx_client.head(\"https://www.example.com/\")\n\n    return HttpResponse(\n        \"OK\",\n        status=HTTPStatus.OK,\n        content_type=\"text/plain; charset=utf-8\",\n    )\n</code></pre>"},{"location":"how_to_use/context_manager/#sequence-diagram","title":"Sequence diagram","text":"Sequence diagram. Please note that the error handling (<code>lifespan.startup.failed</code>, <code>lifespan.shutdown.failed</code>) is not documented in the diagram."},{"location":"how_to_use/signals/","title":"Lifespan signals (low-level)","text":"<p>Tip</p> <p>Developers are advised to prefer asynchronous context managers. Using signals directly is fully supported, and until <code>v0.2.0</code> this was the only way to use this plugin \u2014 the only downside is that it is a more low-level way to use it.</p>"},{"location":"how_to_use/signals/#before-you-start","title":"Before you start","text":"<p>This low-level approach uses ASGI lifespan signals directly. The disadvantage is that the developer has to figure out where to store the global shared state. Prefer the more modern approach via context manager \u2014 the global state will be managed by the ASGI server.</p>"},{"location":"how_to_use/signals/#example-use-case-for-lifespan-signals","title":"Example use case for lifespan signals","text":"<p>Consider a Django application named <code>library</code>. This application retrieves book information from an external API using HTTPX. To ensure efficient utilization of network resources (e.g., connection pooling, see: https://www.python-httpx.org/advanced/#why-use-a-client), we intend to use the HTTPX client.</p>"},{"location":"how_to_use/signals/#typehinting","title":"Typehinting","text":"<p>Firstly, we're going to define a Protocol for typehinting.</p> <p>This Protocol (<code>HTTPXAppConfig</code>) provides an explicit interface for a request that contains a reference to an instance of <code>httpx.AsyncClient</code> in its <code>state</code> dictionary.</p> types.py<pre><code>from typing import Protocol\n\nimport httpx\n\n\nclass HTTPXAppConfig(Protocol):\n    httpx_client: httpx.AsyncClient\n</code></pre>"},{"location":"how_to_use/signals/#signal-receivers","title":"Signal receivers","text":"<p>Next, we create receivers for lifespan signals. A startup receiver that creates an instance of the HTTPX client and a shutdown receiver that closes the client.</p> handlers.py<pre><code>import httpx\n\nfrom .types import HTTPXAppConfig\n\n\nclass ASGILifespanSignalHandler:\n    app_config: HTTPXAppConfig\n\n    def __init__(self, app_config: HTTPXAppConfig):\n        self.app_config = app_config\n\n    async def startup(self, **_):\n        self.app_config.httpx_client = httpx.AsyncClient()\n\n    async def shutdown(self, **_):\n        self.app_config.httpx_client.aclose()\n</code></pre> <p>Connect the receivers to the lifespan signals:</p> apps.py<pre><code>import httpx\nfrom django.apps import AppConfig\n\nfrom django_asgi_lifespan.signals import asgi_shutdown, asgi_startup\nfrom .handlers import ASGILifespanSignalHandler\n\n\nclass ExampleAppConfig(AppConfig):\n    httpx_client: httpx.AsyncClient\n\n    def ready(self):\n        handler = ASGILifespanSignalHandler(app_config=self)\n\n        asgi_startup.connect(handler.startup, weak=False)\n        asgi_shutdown.connect(handler.shutdown, weak=False)\n</code></pre>"},{"location":"how_to_use/signals/#access-shared-state-in-view","title":"Access shared state in view","text":"<p>Now we can access the HTTPX client instance in our view:</p> views.py<pre><code>from typing import cast\n\nfrom django.apps import apps\nfrom django.http import HttpResponse\n\nfrom .types import HTTPXAppConfig\n\n\nasync def my_library_view(*_) -&gt; HttpResponse:\n    library_app = cast(HTTPXAppConfig, apps.get_app_config(\"library\"))\n    httpx_client = library_app.httpx_client\n    external_api_response = await httpx_client.get(\n        \"https://www.example.com/\"\n    )\n\n    return HttpResponse(\n        f\"{external_api_response.text[:42]}\",\n        content_type=\"text/plain\",\n    )\n</code></pre>"}]}